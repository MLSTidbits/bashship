#!/usr/bin/env bash

# bashship - A modular bash prompt system inspired by Starship and Powerlevel10k

# Helpers
function __c () { [[ -z "$1" ]] && set -- 7; echo "\[$(tput setaf "$1")\]"; }

function __bg () { [[ -z "$1" ]] && set -- 0; echo "\[$(tput setab "$1")\]"; }

function __cache-get () { echo -n "${__CACHE[$1]}"; }

function __cache-set () { __CACHE[$1]="$2"; }

# User + Host block

declare -A __CACHE=()

function __user () {

    local color="${USER_COLOR:-2}"
    local colorBG="${USER_COLOR_BG:-}"
    local rootColor="${USER_ROOT_COLOR:-1}"
    local rootColorBG="${USER_ROOT_COLOR_BG:-}"

    local user

    [[ "$EUID" -eq "0" ]] && user="${bold}$(__c "$rootColor")$(__bg "$rootColorBG")\u"
    [[ "$EUID" -gt "0" ]] && user="${bold}$(__c "$color")$(__bg "$colorBG")\u"

    echo -ne "${bold}${user}${reset}"

}

function __host () {

    local color="${HOST_COLOR:-2}"
    local colorBG="${HOST_COLOR_BG:-}"
    local style="${HOST_STYLE:-@}"
    local styleSSH="${HOST_SSH_STYLE:-@ssh:}"
    local sshOnly="${HOST_SSH_ONLY:-false}"

    local host

    # Detect SSH session
    for i in "$SSH_CLIENT" "$SSH_TTY" "$SSH_CONNECTION" ; do
        if [[  -n "$i" ]]; then
            host="$(__c "$color")$(__bg "${colorBG}")${styleSSH}\h"
            break
        fi
    done

    # Local host only if HOST_SSH_ONLY is false
    [[ "$sshOnly" == "false" ]] && host="$(__c "$color")$(__bg "${colorBG}")${style}\h"

    echo -ne "${bold}${host}${reset} ~"

}

# Current working dir
function __dir () {

    local color="${DIR_COLOR:-4}"
    local truncate="${DIR_TRUNCATE:-3}"
    local truncateSymbol="${DIR_TRUNCATE_SYMBOL:-‚Ä¶/}"
    local home="${DIR_HOME_SYMBOL:-üè†}"
    local readonlyColor="${DIR_READONLY_COLOR:-1}"
    local readonlySymbol="${DIR_READONLY_SYMBOL:-üîí}"


    local dir="$PWD"
    dir="${dir/#$HOME}"

    # Split path into parts
    local IFS="/"
    read -ra parts <<< "$dir"

    # Disable DIR_TRUNCATE_SYMBOL if directory is root or home
    [[ ! -w "$PWD" || "$dir" == "$HOME" ]] && truncateSymbol=""

    # Disable DIR_TRUNCATE if in read-only dir
    [[ ! -w "$PWD" ]] && truncate=0

    # Replace home with symbol
    [[ "$dir" == "$HOME"* ]] && parts[0]="$home"
    [[ "$dir" == "/" ]] && parts[0]="/"

    # Apply truncation
    if (( ${#parts[@]} > truncate )); then
        parts=("${parts[@]: -$truncate}")
        dir="${truncateSymbol}${parts[*]// /\/}"
    fi

    # Color based on write permissions
    [[ -w "$PWD" ]] && dir="$(__c "$color")${dir}"

    # Read-only indicator
    [[ ! -w "$PWD" ]] && dir+=" $(__c "$readonlyColor")${readonlySymbol}"

    echo -ne " ${bold}$dir${reset}"
}

function __git-branch () {

    local color="${GIT_COLOR:-5}"
    local gitSymbol="${GIT_SYMBOL:-}"
    local open="${GIT_OPEN:-[}"

    command -v git >/dev/null 2>&1 || return

    # shellcheck disable=SC2155
    local branch="$(git symbolic-ref --short HEAD 2>/dev/null)"

    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return

    [[ -n "$gitSymbol" ]] && gitSymbol=" $gitSymbol"

    [[ -n "$branch" ]] &&
    echo -ne " $(__c "$color")${open}${reset} $branch$gitSymbol"

}

# Git status with Starship-style symbols, colored, no brackets, using && logic
function __git-status () {

    local color="${GIT_COLOR:-5}"
    local gitClose="${GIT_CLOSE:-]}"

    local conflict="${GIT_CONFLICT:-‚úñ}"
    local untracked="${GIT_UNTRACKED:-?}"
    local staged="${GIT_STAGED:-+}"
    local modified="${GIT_MODIFIED:-~}"
    local deleted="${GIT_DELETED:-\-}"
    local ahead="${GIT_AHEAD:-‚á°}"
    local behind="${GIT_BEHIND:-‚á£}"
    local clean="${GIT_CLEAN:-‚úî}"

    local symbols=""

    # shellcheck disable=SC2155
    local status=$(__cache-get git_status)

    command -v git >/dev/null 2>&1 || return

    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return

    if [[ -z "$status" ]]; then
        # Cache miss ‚Üí recompute
        status="$(git status --porcelain -b 2>/dev/null)"
        __cache-set git_status 5 "$status"
    fi

    echo "$status" | grep -q '^UU' && symbols+=" $(__c 9)$conflict$reset"
    echo "$status" | grep -q '^??' && symbols+=" $(__c 14)$untracked$reset"
    echo "$status" | grep -q '^M\ ' && symbols+=" $(__c 11)$staged$reset"
    echo "$status" | grep -q '^\ M' && symbols+=" $(__c 2)$modified$reset"
    echo "$status" | grep -q '^\ D' && symbols+=" $(__c 1)$deleted$reset"

    # Clean working directory
    [[ -z "$status" ]] && symbols+="$(__c 2)$clean$reset"

    # Ahead of remote
    # shellcheck disable=SC1083
    a=$(git rev-list --count \
    --left-right @{upstream}...HEAD 2>/dev/null | awk '{print $2}')
    [[ $a -gt 0 ]] && symbols+=" $(__c 5)$ahead$reset"

    # Behind remote
    # shellcheck disable=SC1083
    b=$(git rev-list --count \
    --left-right @{upstream}...HEAD 2>/dev/null | awk '{print $1}')
    [[ $b -gt 0 ]] && symbols+=" $(__c 1)$behind$reset"

    # Output
    echo -ne " $symbols $(__c "$color")${gitClose}${reset}"

}

# Time
function __time () {

    local color="${TIME_COLOR:-7}"
    local type="${TIME_12H:-false}"

    local format="+%H:%M"   # default 24h

    [[ "$type" == "true" ]] && format="+%I:%M %p"

    echo -ne " $(__c "$color")$(date "$format")${reset}"
}

# Background jobs
function __jobs () {

    local color="${JOBS_COLOR:-3}"
    local symbol="${JOBS_SYMBOL:-‚öô}"

    # shellcheck disable=SC2155
    local count=$(jobs -p | wc -l)
    [[ $count -gt 0 ]] && echo -ne " $(__c "$color")$symbol - $count${reset}"
}

function __container () {

    local color="${CONTAINER_COLOR:-6}"
    local symbol="${CONTAINER_SYMBOL:-üõ¢}"

    while read -r line; do
        [[ "$line" == *"lxc"* ]] && container=" $(c__c "$color")$symbol$reset: LXC"
        [[ "$line" == *"kubepod"* ]] && container=" $(c__c "$color")$symbol$reset: K8S"
        [[ "$line" == *"docker"* ]] && container=" $(c__c "$color")$symbol$reset: Docker"
        [[ "$line" == *"podman"* ]] && container=" $(c__c "$color")$symbol$reset: Podman"
    done < /proc/1/environ

    [[ -n "$container" ]] && echo -ne "$bold$container"

}

# Load user config if exists
[[ -f "$HOME/.config/bashship.conf" ]] &&
source "$HOME/.config/bashship.conf" 2> /dev/null

promptOrder=("${PROMPT_ORDER[@]:-user host path git-branch git-status time jobs container}")

newline="${NEWLINE:-false}"
nextline="${NEXTLINE:-true}"
character="${CHARACTER:-‚ûú}"
characterColor="${CHARACTER_COLOR:-2}"
characterColorError="${CHARACTER_COLOR_ERROR:-1}"

app="bashship"
ver="$(cat /usr/share/doc/bashship/version 2>/dev/null ||
echo 'unknown version')"

reset="\[$(tput sgr0)\]"
bold="\[$(tput bold)\]"

case "$1" in --version|-v ) echo "$app $ver" ; exit 0 ;; esac

# Modular prompt builder
function __bash-prompt () {

    # shellcheck disable=SC2153
    [[ "$?" -gt "0" ]] &&
    symbol="$(__c "$characterColorError")$character${reset}" ||
    symbol="$(__c "$characterColor")$character${reset}"

    local ps=""

    for mod in "${promptOrder[@]}"; do case $mod in
        user                ) ps+="$(__user)"       ;;
        host                ) ps+="$(__host)"       ;;
        path                ) ps+="$(__dir)"        ;;
        git-branch          ) ps+="$(__git-branch)" ;;
        git-status          ) ps+="$(__git-status)" ;;
        time                ) ps+="$(__time)"       ;;
        jobs                ) ps+="$(__jobs)"       ;;
        container           ) ps+="$(__container)"  ;;
    esac done

    [[ "$nextline" == "true" ]] && ps+="\n${symbol}"
    [[ "$nextline" == "false" ]] && ps+=" ${symbol}"

    [[ "$newline" == "true" ]] && ps="\n$ps"

    PS1="$ps "
}

PROMPT_COMMAND="__bash-prompt;$PROMPT_COMMAND"
