#!/usr/bin/env bash

# bashship - A modular bash prompt system inspired by Starship and Powerlevel10k

# Load user config if exists
[[ -f "$HOME/.config/bashship.conf" ]] &&
source "$HOME/.config/bashship.conf" 2> /dev/null

[[ ! -f "$HOME/.config/bashship.conf" ]] &&
source /usr/share/bashship/bashship.conf 2> /dev/null

_name="bashship"
_version="$(cat /usr/share/doc/bashship/version 2>/dev/null || echo 'unknown version')"

RESET="\[$(tput sgr0)\]"
BOLD="\[$(tput bold)\]"

# Helpers
function __c () { [[ -z "$1" ]] && set -- 7; echo "\[$(tput setaf "$1")\]"; }

function __bg () { [[ -z "$1" ]] && set -- 0; echo "\[$(tput setab "$1")\]"; }

function __cache-get () { echo -n "${__CACHE[$1]}"; }

function __cache-set () { __CACHE[$1]="$2"; }

# User + Host block

function __user () {

    local user="\u"

    [[ "$EUID" -eq "0" ]] &&
    echo -ne "${BOLD}$(__c "$USER_ROOT_COLOR")$(__bg "$USER_ROOT_COLOR_BG")${user}${RESET}"
    [[ "$EUID" -gt "0" ]] &&
    echo -ne "${BOLD}$(__c "$USER_COLOR")$(__bg "$USER_COLOR_BG")${user}${RESET}"

}

function __host () {

    local _host=" ~"

    # Show hostname only if SSH, prefixed with "ssh:"
    [[ "$HOST_SSH_ONLY" == "true" ]] && [[ -n "$SSH_CLIENT" || -n "$SSH_TTY" || -n "$SSH_CONNECTION" ]] &&
    _host="$(__c "$HOST_COLOR")$HOST_SSH_STYLE\h${RESET} ~"

    [[ "$HOST_ENABLE" == "true" ]] && _host="$(__c "$HOST_COLOR")@\h${RESET} ~"

    echo -ne "${BOLD}$_host${RESET}"

}

# Current working dir
function __dir () {

    local dir="$PWD"
    dir="${dir/#$HOME}"

    # Split path into parts
    local IFS="/"
    read -ra parts <<< "$dir"

    # Disable DIR_TRUNCATE_SYMBOL if directory is root or home
    [[ ! -w "$PWD" || "$dir" == "$HOME" ]] && DIR_TRUNCATE_SYMBOL=""

    # Disable DIR_TRUNCATE if in read-only dir
    [[ ! -w "$PWD" ]] && DIR_TRUNCATE=0

    # Replace home with symbol
    [[ "$dir" == "$HOME"* ]] && parts[0]="$DIR_HOME_SYMBOL"
    [[ "$dir" == "/" ]] && parts[0]="/"

    # Apply truncation
    if (( ${#parts[@]} > DIR_TRUNCATE )); then
        parts=("${parts[@]: -$DIR_TRUNCATE}")
        dir="${DIR_TRUNCATE_SYMBOL}${parts[*]// /\/}"
    fi

    # Color based on write permissions
    [[ ! -w "$PWD" ]] && dir="$(__c "$DIR_READONLY_COLOR")${dir}${RESET}"
    [[ -w "$PWD" ]] && dir="$(__c "$DIR_COLOR")${dir}${RESET}"

    # Read-only indicator
    [[ ! -w "$PWD" ]] &&
    dir+=" $(__c "$DIR_READONLY_COLOR")${DIR_READONLY_SYMBOL}${RESET}"

    echo -ne " $dir"
}

function __git-branch () {

    command -v git >/dev/null 2>&1 || return

    # shellcheck disable=SC2155
    local branch="$(git symbolic-ref --short HEAD 2>/dev/null)"

    [[ -z "$GIT_SYMBOL" ]] && gitSymbol="" || gitSymbol="$GIT_SYMBOL"

    [[ "$GIT_ENABLE" == "false" ]] && return

    if [[ -n "$branch" ]]; then
        echo -ne " $(__c "$GIT_COLOR")${GIT_OPEN}${RESET} $branch$gitSymbol"
    else
        echo -ne ""
    fi

}

# Git status with Starship-style symbols, colored, no brackets, using && logic
function __git-status () {

    local symbols="" _status ahead behind

    [[ "$GIT_STATUS_ENABLE" == "false" ]] && return

    command -v git >/dev/null 2>&1 || return

    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return

    _status=$(__cache-get git_status)
    if [[ -z "$status" ]]; then
        # Cache miss â†’ recompute
        _status="$(git status --porcelain -b 2>/dev/null)"
        __cache-set git_status 5 "$_status"
    fi

    # Append symbols if conditions are met
    echo "$_status" | grep -q '^UU' && symbols+=" $(__c 9)$GIT_CONFLICT$RESET"
    echo "$_status" | grep -q '^??' && symbols+=" $(__c 14)$GIT_UNTRACKED$RESET"
    echo "$_status" | grep -q '^M\ ' && symbols+=" $(__c 11)$GIT_STAGED$RESET"
    echo "$_status" | grep -q '^\ M' && symbols+=" $(__c 2)$GIT_MODIFIED$RESET"
    echo "$_status" | grep -q '^\ D' && symbols+=" $(__c 1)$GIT_DELETED$RESET"

    # Clean working directory
    [[ -z "$_status" ]] && symbols+="$GIT_CLEAN"

    # Ahead of remote
    # shellcheck disable=SC1083
    ahead=$(git rev-list --count \
    --left-right @{upstream}...HEAD 2>/dev/null | awk '{print $2}')

    # Behind remote
    # shellcheck disable=SC1083
    behind=$(git rev-list --count \
    --left-right @{upstream}...HEAD 2>/dev/null | awk '{print $1}')

    # shellcheck disable=SC2153
    [[ $ahead -gt 0 ]] && symbols+=" $(__c 5)$AHEAD$RESET"
    [[ $behind -gt 0 ]] && symbols+=" $(__c 1)$GIT_BEHIND$RESET"

    # Output
    echo -ne " $symbols $(__c "$GIT_COLOR")${GIT_CLOSE}${RESET}"

}

# Time
function __time () {

    local _timeFormat="+%H:%M"   # default 24h

    [[ "$TIME_ENABLE" == "false" ]] && return
    [[ "$TIME_12H" == "true" ]] && _timeFormat="+%I:%M %p"

    echo -ne " $(__c "$TIME_COLOR")$(date "$_timeFormat")${RESET}"
}

# Background jobs
function __jobs () {

    # shellcheck disable=SC2155
    local count=$(jobs -p | wc -l)
    [[ $count -gt 0 ]] && echo -ne " J: $JOBS_COLOR$count$RESET"
}

function __container () {

    grep -qa 'lxc' /proc/1/evniron && echo -ne " ${CONTAINER_COLOR}lxc$RESET"

    [[ -f /.dockerenv ]] || grep -qa 'docker' /proc/1/evniron &&
    echo -ne " ${CONTAINER_COLOR}docker$RESET"

    [[ -f /run/systemd/container ]] && grep -q 'nspawn' /run/systemd/container &&
    echo -ne " ${CONTAINER_COLOR}nspawn$RESET"

}

# Modular prompt builder
function bash_prompt() {

    # shellcheck disable=SC2153
    [[ "$?" -gt "0" ]] &&
    symbol="$(__c "$SYMBOL_COLOR_ERROR")$SYMBOL${RESET}" ||
    symbol="$(__c "$SYMBOL_COLOR")$SYMBOL${RESET}"

    local ps=""

    for mod in "${PROMPT_ORDER[@]}"; do case $mod in
        user                ) ps+="$(__user)"       ;;
        host                ) ps+="$(__host)"       ;;
        path                ) ps+="$(__dir)"        ;;
        git-branch          ) ps+="$(__git-branch)" ;;
        git-status          ) ps+="$(__git-status)" ;;
        time                ) ps+="$(__time)"       ;;
        jobs                ) ps+="$(__jobs)"       ;;
        container           ) ps+="$(__container)"  ;;
    esac done

    [[ "$NEXTLINE" == "true" ]] && ps+="\n${symbol}"
    [[ "$NEXTLINE" == "false" ]] && ps+=" ${symbol}"

    [[ "$NEWLINE" == "true" ]] && ps="\n$ps"

    PS1="$ps "
}
